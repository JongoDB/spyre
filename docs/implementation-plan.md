# Spyre — Implementation Plan

> This is the build sequence. Work through phases in order. Do not skip ahead.
> Architecture details: `docs/spyre-architecture.md`
> Coding conventions: `CLAUDE.md` (project root)
> Environment values: `environment.yaml` (project root, auto-generated by `setup.sh`)

---

## Phase 0: Project Scaffold

**Goal**: Empty SvelteKit app that starts, connects to SQLite, and loads environment config.

### Tasks

- [ ] Initialize SvelteKit project with TypeScript strict mode
  ```bash
  npx sv create spyre --template minimal --types ts
  ```
- [ ] Install core dependencies
  ```bash
  npm install better-sqlite3 ssh2 yaml uuid
  npm install -D @types/better-sqlite3 @types/ssh2 vitest
  ```
- [ ] Install frontend dependencies
  ```bash
  npm install @xterm/xterm @xterm/addon-fit @xterm/addon-webgl
  npm install @codemirror/lang-yaml @codemirror/state @codemirror/view
  ```
- [ ] Create directory structure
  ```
  src/
  ├── lib/
  │   ├── server/
  │   │   ├── db.ts              # SQLite singleton
  │   │   ├── env-config.ts      # Loads environment.yaml, exports typed config
  │   │   ├── proxmox.ts         # (stub) Proxmox API client
  │   │   ├── ssh-pool.ts        # (stub) SSH connection manager
  │   │   ├── claude-auth.ts     # (stub) OAuth relay
  │   │   ├── claude-bridge.ts   # (stub) Claude process manager
  │   │   ├── provisioner.ts     # (stub) 3-phase pipeline
  │   │   └── config-store.ts    # (stub) YAML config loader
  │   ├── types/
  │   │   ├── environment.ts     # DB model types
  │   │   ├── proxmox.ts         # Proxmox API response types
  │   │   ├── config.ts          # YAML config schema types
  │   │   └── claude.ts          # Claude task/auth types
  │   └── components/
  │       └── (empty for now)
  └── routes/
      └── +page.svelte           # Placeholder landing page
  ```
- [ ] Create `schema.sql` from the architecture doc's database schema (Section 10)
- [ ] Implement `src/lib/server/db.ts`:
  - Opens/creates SQLite database at path from `environment.yaml`
  - Runs `schema.sql` on first boot (check for tables before applying)
  - Exports `db` singleton
- [ ] Implement `src/lib/server/env-config.ts`:
  - Loads `environment.yaml` from project root
  - Parses and validates with the `yaml` package
  - Exports typed `envConfig` singleton
  - Throws clear error on startup if `environment.yaml` is missing (directs user to run `setup.sh`)
- [ ] Create `spyre.service` systemd unit file
- [ ] Create base `Caddyfile`
- [ ] **Verify**: `npm run dev` starts without errors, SQLite DB is created, environment config loads

### Definition of Done
The app starts. Navigating to `http://localhost:5173` shows a page. SQLite DB exists with all tables. Console logs show environment config loaded successfully. No stubs are called yet.

---

## Phase 1: Proxmox Connectivity

**Goal**: List, create, and destroy LXC containers from the Spyre web UI.

### Tasks

- [ ] Implement `src/lib/server/proxmox.ts` — full Proxmox API client:
  - `authenticate()` — validates API token works (GET `/api2/json/version`)
  - `listNodes()` — GET `/nodes`
  - `listLxc(node)` — GET `/nodes/{node}/lxc`
  - `listVm(node)` — GET `/nodes/{node}/qemu`
  - `getLxcStatus(node, vmid)` — GET `/nodes/{node}/lxc/{vmid}/status/current`
  - `createLxc(node, config)` — POST `/nodes/{node}/lxc`
  - `destroyLxc(node, vmid)` — DELETE `/nodes/{node}/lxc/{vmid}` with `purge=1`
  - `startLxc(node, vmid)` — POST `/nodes/{node}/lxc/{vmid}/status/start`
  - `stopLxc(node, vmid)` — POST `/nodes/{node}/lxc/{vmid}/status/stop`
  - `getNextVmid()` — GET `/cluster/nextid`
  - `listTemplates(node, storage)` — GET `/nodes/{node}/storage/{storage}/content` filtered by `content=vztmpl`
  - `getTaskStatus(node, upid)` — GET `/nodes/{node}/tasks/{upid}/status` (Proxmox operations are async — returns UPID, poll for completion)
  - All methods: proper error handling per CLAUDE.md conventions, reads connection details from `env-config.ts`
  - Uses `fetch` with `rejectUnauthorized: false` for self-signed Proxmox certs (or configurable CA)
- [ ] Create type definitions in `src/lib/types/proxmox.ts` for all API responses
- [ ] Build `src/routes/environments/+page.server.ts`:
  - Loads environments from DB + live status from Proxmox API
  - Merges: DB has our metadata, Proxmox has real-time status (running/stopped/etc.)
- [ ] Build `src/routes/environments/+page.svelte`:
  - Lists environments as cards with status indicators
  - [+ Create Environment] button → opens simple form (hostname, template, cores, memory, disk)
  - [Destroy] button per environment with confirmation
  - [Start] / [Stop] buttons per environment
- [ ] Create API routes:
  - `POST /api/environments` — creates LXC via Proxmox API, records in DB
  - `DELETE /api/environments/[id]` — destroys LXC, updates DB
  - `POST /api/environments/[id]/start` — starts LXC
  - `POST /api/environments/[id]/stop` — stops LXC
- [ ] Implement Proxmox task polling: after `createLxc`, poll `getTaskStatus` until complete, then update DB with IP address
- [ ] Write tests for `proxmox.ts` with mocked HTTP responses (at minimum: auth success/failure, create success/error, destroy, list)
- [ ] **Verify**: can create an LXC from the web UI, see it appear in Proxmox, see it listed in Spyre, and destroy it

### Definition of Done
User can navigate to `/environments`, see existing Proxmox LXCs, create a new one with a form, and destroy it. All from the browser. Status updates reflect real Proxmox state.

---

## Phase 2: SSH + Terminal

**Goal**: Open a browser-based terminal to any running environment.

### Tasks

- [ ] Implement `src/lib/server/ssh-pool.ts`:
  - Maintains a map of active SSH connections keyed by `env_id`
  - `getConnection(envId)` — returns existing or creates new `ssh2.Client`
  - Reads SSH key path and connection settings from `env-config.ts`
  - Handles: connection timeout, auth failure, unexpected disconnect, reconnect
  - SSH keepalive: `keepaliveInterval: 30000, keepaliveCountMax: 5`
  - Connection multiplexing: one `ssh2.Client` per host, multiple channels
- [ ] Implement `src/lib/server/tmux-controller.ts`:
  - `ensureSession(connection, sessionName)` — creates tmux session if it doesn't exist
  - `listWindows(connection, sessionName)` — returns window index + name list
  - `createWindow(connection, sessionName, windowName?)` — new tmux window
  - `attachToWindow(connection, sessionName, windowIndex)` — returns a stream (SSH channel running `tmux attach`)
  - `killSession(connection, sessionName)` — cleanup
  - Default session name: `spyre`
- [ ] Set up WebSocket endpoint: `src/routes/api/terminal/[envId]/+server.ts`
  - Upgrades HTTP to WebSocket
  - On connect: gets SSH connection from pool → ensures tmux session → attaches to window
  - Bidirectional pipe: WebSocket ↔ SSH channel (tmux)
  - On WebSocket close: detach from tmux (session persists on worker)
  - On SSH channel close: notify client, offer reconnect
  - Handle terminal resize: client sends resize events, relay to tmux via SSH channel
- [ ] Build `src/lib/components/Terminal.svelte`:
  - Wraps xterm.js with addon-fit and addon-webgl
  - Connects to WebSocket endpoint for given environment
  - Handles: connection state indicators, reconnect on disconnect, resize on container change
  - Exposes: `connect()`, `disconnect()`, `sendInput()`, `resize()`
- [ ] Build `src/lib/components/TerminalTabs.svelte`:
  - Tabbed container for multiple Terminal instances
  - [+ New Tab] creates new tmux window via API call, opens new Terminal
  - Tab close detaches from tmux window (doesn't kill it)
  - Tab names synced with tmux window names
- [ ] Add terminal view to environment detail page: `src/routes/environments/[id]/+page.svelte`
  - Shows environment info at top
  - TerminalTabs component below
  - Only enabled when environment status is `running`
- [ ] Inject Spyre SSH public key during LXC creation (update Phase 1's create flow):
  - Use Proxmox API's `ssh-public-keys` parameter during LXC creation
  - Verify SSH connectivity after creation before marking environment as `running`
- [ ] Write tests for: ssh-pool connection lifecycle, tmux-controller commands, WebSocket message handling
- [ ] **Verify**: create an LXC, navigate to it, open terminal, type commands, close browser tab, reopen, tmux session is still there

### Definition of Done
User opens an environment's detail page, sees a terminal tab, types `ls` and sees output. Opens a second tab. Closes the browser entirely, reopens, reattaches to the same tmux session with history intact.

---

## Phase 3: Config System

**Goal**: Define environments as YAML files, provision them with a single click.

### Tasks

- [ ] Define config schema types in `src/lib/types/config.ts`:
  - `SpyreEnvironmentConfig` — full config shape matching the arch doc's `spyre.yaml` example
  - `SpyreBaseConfig` — for base/inheritable configs
  - Validation function: `validateConfig(raw: unknown): { valid: boolean, errors: string[] }`
- [ ] Implement `src/lib/server/config-store.ts`:
  - `listConfigs()` — scans `configs/` directory, returns metadata
  - `loadConfig(name)` — loads YAML, resolves `extends` inheritance (deep merge), validates
  - `saveConfig(name, content)` — writes YAML to `configs/`, validates before saving
  - `deleteConfig(name)` — removes file
  - Inheritance resolution: load base, deep-merge spec fields, arrays in `provision.packages` are concatenated (not replaced), everything else is overwritten
- [ ] Build config editor page: `src/routes/configs/+page.svelte`
  - Lists all configs from `configs/` directory
  - Click to open in editor
  - [+ New Config] with template selection (blank, from base, clone existing)
- [ ] Build `src/routes/configs/editor/+page.svelte`:
  - CodeMirror 6 with YAML syntax highlighting
  - Live validation: on every change, run `validateConfig`, show errors inline
  - [Save] button
  - [Provision] button — creates environment from this config
- [ ] Implement `src/lib/server/provisioner.ts` — the 3-phase pipeline:
  - **Phase 1**: Call `proxmox.createLxc()` with values from config's `spec.platform`
  - **Phase 2**: If `spec.helper_script` is set, SSH to Proxmox host and run the install portion
  - **Phase 3**: SSH into the new container and execute `spec.provision` (install packages, run scripts, copy files)
  - Each phase: emit progress events (for real-time UI updates), handle errors at each stage, record status in DB
  - Rollback on failure: if Phase 3 fails, the LXC still exists but is marked `error` with details
- [ ] Update the create environment UI to support both:
  - Quick create (manual form from Phase 1 — still works)
  - Config-based create (select a config, one-click provision)
- [ ] Create example configs:
  - `configs/bases/ubuntu-dev.yaml` — base Ubuntu dev environment
  - `configs/dev-web.yaml` — extends ubuntu-dev, adds Node.js + Nginx
- [ ] Write tests for: config loading, inheritance merging, validation (valid + invalid configs), provisioner Phase 1 + Phase 3 (mocked SSH)
- [ ] **Verify**: create a config in the editor, save it, click Provision, watch all 3 phases execute, end up with a working environment matching the config

### Definition of Done
User writes a YAML config in the browser editor, clicks Provision, and gets a fully configured LXC container with all packages installed and scripts executed. The environment appears in the list and is terminally accessible.

---

## Phase 4: Claude Code Integration

**Goal**: Authenticate Claude Code via OAuth, dispatch tasks, stream output.

### Tasks

- [ ] Implement `src/lib/server/claude-auth.ts` — the full OAuth relay service from arch doc Section 4:
  - `initiateAuth()` — spawns `claude /login`, captures OAuth URL, rewrites callback
  - `handleCallback(params)` — relays OAuth callback to Claude Code's localhost server
  - `checkAuthStatus()` — verifies `auth.json` exists and token is valid
  - `cancelAuth()` — kills orphaned auth processes
  - Health check timer: polls every 60s, emits events on expiry/warning
  - Full error handling per the arch doc's error matrix
- [ ] Create auth routes:
  - `POST /auth/claude/initiate` — starts OAuth flow, returns URL
  - `GET /auth/claude/callback` — receives Anthropic redirect, relays to Claude Code
  - `GET /auth/claude/status` — returns current auth state
  - `POST /auth/claude/cancel` — cancels in-progress auth
- [ ] Build `src/lib/components/ClaudeAuthPanel.svelte`:
  - Status indicator (green/yellow/red)
  - Authenticate / Re-authenticate button
  - Token expiry warning
  - Error messages with retry
- [ ] Build `src/routes/settings/claude/+page.svelte`:
  - Embeds ClaudeAuthPanel
  - Shows auth history from `claude_auth_log` table
- [ ] Implement `src/lib/server/claude-bridge.ts` — task dispatch:
  - `dispatch(taskId, prompt, options)` — spawns `claude -p` with auth pre-check
  - Monitors stderr for auth failures mid-task
  - Streams stdout via EventEmitter for real-time WebSocket push
  - Records task in `claude_tasks` table with cost, session ID, result
  - Supports resume via `claude --resume <session-id>`
- [ ] Set up WebSocket endpoint for Claude output streaming: `src/routes/api/claude/[taskId]/+server.ts`
- [ ] Build Claude dispatch UI per environment: `src/routes/environments/[id]/claude/+page.svelte`:
  - Text input for task prompt
  - [Run] button (disabled if Claude not authenticated)
  - Real-time output stream display
  - Task history for this environment
  - [Resume] button for incomplete tasks
- [ ] Build `src/routes/claude/sessions/+page.svelte`:
  - Lists all Claude tasks across all environments
  - Filter by status, environment, date
  - Click to view full output
- [ ] Write tests for: auth state machine transitions, callback relay (mocked HTTP), dispatch with mocked Claude process, auth failure detection
- [ ] **Verify**: authenticate Claude via the settings page, navigate to an environment, dispatch a task like "list all files in /etc", see output stream in real-time, see task recorded in history

### Definition of Done
Claude Code is authenticated via browser OAuth flow. User can dispatch tasks to any environment and see real-time streamed output. Auth expiry is detected and re-auth is prompted. Task history is queryable.

---

## Phase 5: Polish & Hardening

**Goal**: Production-ready single-user deployment.

### Tasks

- [ ] Implement user auth:
  - `src/lib/server/auth.ts` — bcrypt password hashing, session management
  - Login page: `src/routes/login/+page.svelte`
  - Session middleware: check auth on all routes except `/login` and `/auth/claude/callback`
  - First-boot: if no users exist, show account creation form
- [ ] Implement Caddy dynamic proxy:
  - `src/lib/server/proxy-manager.ts` — generates Caddyfile snippets per environment's services
  - On environment create/destroy: regenerate + `caddy reload`
  - Service health checks: periodic HTTP probe of declared service ports
- [ ] Build dashboard landing page (`src/routes/+page.svelte`):
  - Environment count + status summary
  - Claude auth status indicator
  - Recent Claude tasks
  - Quick actions: create environment, open terminal to recent env
- [ ] Add environment status polling:
  - Background job: every 30s, poll Proxmox for live status of all environments
  - Update DB + push status changes via WebSocket to connected browsers
- [ ] Implement audit logging:
  - Wrap all mutating operations (create, destroy, start, stop, claude dispatch) with audit log entries
  - `src/routes/settings/audit/+page.svelte` — view audit log
- [ ] Error page: `src/routes/+error.svelte` — styled error display
- [ ] Write E2E tests with Playwright:
  - Full flow: login → create environment → open terminal → type command → destroy environment
  - Claude auth flow (mocked OAuth)
  - Config editor → provision flow
- [ ] Performance: ensure terminal WebSocket handles reasonable throughput (e.g., `cat` a large file)
- [ ] Security audit:
  - Verify no env-specific secrets leak to browser
  - Verify SQL injection prevention
  - Verify WebSocket auth (no unauthenticated terminal access)
  - Verify Caddy proxy doesn't expose unintended routes
- [ ] Write `README.md` for the project

### Definition of Done
Single-user deployment is secure, polished, and handles edge cases gracefully. All Phase 0-4 features work together. Setup from scratch on a fresh Ubuntu VM takes under 15 minutes.

---

## Build Rules

1. **Complete each phase before starting the next.** Phases build on each other.
2. **Verify at the end of each phase.** Run the verification step. If it fails, fix it before moving on.
3. **Don't gold-plate.** If something works and meets the Definition of Done, move on.
4. **Reference `environment.yaml` for all infra values.** Never hardcode IPs, hostnames, or Proxmox-specific identifiers.
5. **Reference `docs/verified-examples.md` for integration patterns.** If there's a tested curl command that works, match its behavior in code.
6. **Ask before building Phase 2+ features.** The "What NOT to Build (Yet)" section in CLAUDE.md is authoritative.
